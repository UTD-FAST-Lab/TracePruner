package dev.c0pslab.analysis;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.traverse.BreadthFirstIterator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import picocli.CommandLine;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityAnalysis implements Runnable {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityAnalysis.class);

    @CommandLine.Option(names = {"-i", "--input"}, description = "Input to the JSON file containing static CGs," +
            " their pruned version and nodes containing fake CVEs")
    String inputJSONFile;

    @CommandLine.Option(names = {"-o", "--output"}, description = "The output JSON file containing the results of the vulnerability analysis")
    String outputJSONFile;

    private Map<String, Map<String, CGInfo>> cgs;

    public static void main(String[] args) {
        System.exit(new CommandLine(new VulnerabilityAnalysis()).execute(args));
    }

    @Override
    public void run() {
        var mapper = new ObjectMapper();
        mapper.enable(SerializationFeature.INDENT_OUTPUT);
        try {
            cgs = mapper.readValue(new File(inputJSONFile), new TypeReference<>() {});
            var vulnerabilityAnalysisResults = runAnalysis(); // Warm up!
            LOG.info("Warm up is done!");
            vulnerabilityAnalysisResults = runAnalysis();
            mapper.writeValue(new File(outputJSONFile), vulnerabilityAnalysisResults);
            LOG.info("Vulnerability Analysis is Done!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private HashMap<String, List<VulnerabilityInfo>> runAnalysis() {
        var vulnerabilityAnalysisResults = new HashMap<String, List<VulnerabilityInfo>>();
        performReachabilityAnalysis("wala", vulnerabilityAnalysisResults, 3);
        performReachabilityAnalysis("codebert", vulnerabilityAnalysisResults, 3);
        performReachabilityAnalysis("codebert_C99", vulnerabilityAnalysisResults, 3);
        performReachabilityAnalysis("codet5", vulnerabilityAnalysisResults, 3);
        performReachabilityAnalysis("codet5_C99", vulnerabilityAnalysisResults, 3);
        performReachabilityAnalysis("RC", vulnerabilityAnalysisResults, 3);
        return vulnerabilityAnalysisResults;
    }

    private void performReachabilityAnalysis(final String callGraphDataName,
                                             final HashMap<String, List<VulnerabilityInfo>> vulnerabilityAnalysisResults,
                                             final int numberOfMeasurements) {
        vulnerabilityAnalysisResults.put(callGraphDataName, new ArrayList<>());
        for (var e : cgs.get(callGraphDataName).entrySet()) {
            var program = e.getKey();
            var programCG = e.getValue().cg;
            var programCGGraph = e.getValue().convertCGToGraph();
            HashSet<String> programCGSrcNodes = e.getValue().sourceNodes;
//            HashSet<String> programCGVulnNodes = e.getValue().vulnerableNodes;
            var programCGVulnNodes = cgs.get("wala").get(program).vulnerableNodes;

            // Perform BFS for each source node and check reachability to vulnerable nodes
            Map<String, Set<String>> reachableVulnerableNodes = new HashMap<>();
            int numberOfReachablePaths = 0;
            long totalTime = 0;
            for (int i = 0; i < numberOfMeasurements; i++) {
                var startTime = System.nanoTime();
                numberOfReachablePaths = doBFSSearch(programCGGraph, programCGSrcNodes, programCGVulnNodes,
                        reachableVulnerableNodes);
                var executionTime = System.nanoTime() - startTime;
                totalTime += executionTime;
            }
            double averageExecutionTime = (double) (totalTime / numberOfMeasurements) / 1_000_000.0; // To miliseconds
            final int numberOfReachableVulnNodes = reachableVulnerableNodes.values().stream()
                    .flatMap(Set::stream)
                    .collect(Collectors.toSet())
                    .size();

            LOG.info("Number of reachable paths for program " + program + " is: " + numberOfReachablePaths);
            LOG.info("Number of reachable vuln. nodes for program " + program + " is: " + numberOfReachableVulnNodes);
            LOG.info("Finished reachability analysis for program " + program + " in " + averageExecutionTime + " ms");
            vulnerabilityAnalysisResults.get(callGraphDataName).add(new VulnerabilityInfo(program, numberOfReachablePaths,
                    numberOfReachableVulnNodes, averageExecutionTime, programCGGraph.vertexSet().size(), programCGGraph.edgeSet().size()));
        }
    }

    private static int doBFSSearch(final Graph programCGGraph, final HashSet<String> programCGSrcNodes,
                                   final HashSet<String> programCGVulnNodes,
                                   final Map<String, Set<String>> reachableVulnerableNodes) {
        var numberOfReachablePaths = 0;
        for (String source : programCGSrcNodes) {
            Set<String> reachableFromSource = new HashSet<>();
            var iterator = new BreadthFirstIterator<String, DefaultEdge>(programCGGraph, source);
            while (iterator.hasNext()) {
                var node = iterator.next();
                if (programCGVulnNodes.contains(node)) {
                    reachableFromSource.add(node);
//                            LOG.info("Found a path from " + source + " to the vulnerable node " + node);
                    numberOfReachablePaths++;
                }
            }
            reachableVulnerableNodes.put(source, reachableFromSource);
        }
        return numberOfReachablePaths;
    }

    public static class VulnerabilityInfo {
        public String program;
        public int numOfReachablePaths;
        public int numOfReachableVulnNodes;
        public double reachabilityAnalysisTime;
        public int numOfCGNodes;
        public int numOfCGEdges;

        public VulnerabilityInfo() {}

        public VulnerabilityInfo(String program, int numOfReachablePaths, int numOfReachableVulnNodes,
                                 double reachabilityAnalysisTime, int numOfCGNodes, int numOfCGEdges) {
            this.program = program;
            this.numOfReachablePaths = numOfReachablePaths;
            this.numOfReachableVulnNodes = numOfReachableVulnNodes;
            this.reachabilityAnalysisTime = reachabilityAnalysisTime;
            this.numOfCGNodes = numOfCGNodes;
            this.numOfCGEdges = numOfCGEdges;
        }

        public String getProgram() {
            return program;
        }

        public void setProgram(String program) {
            this.program = program;
        }

        public int getNumOfReachablePaths() {
            return numOfReachablePaths;
        }

        public void setNumOfReachablePaths(int numOfReachablePaths) {
            this.numOfReachablePaths = numOfReachablePaths;
        }

        public int getNumOfReachableVulnNodes() {
            return numOfReachableVulnNodes;
        }

        public void setNumOfReachableVulnNodes(int numOfReachableVulnNodes) {
            this.numOfReachableVulnNodes = numOfReachableVulnNodes;
        }

        public double getReachabilityAnalysisTime() {
            return reachabilityAnalysisTime;
        }

        public void setReachabilityAnalysisTime(double reachabilityAnalysisTime) {
            this.reachabilityAnalysisTime = reachabilityAnalysisTime;
        }

        public int getNumOfCGNodes() {
            return numOfCGNodes;
        }

        public void setNumOfCGNodes(int numOfCGNodes) {
            this.numOfCGNodes = numOfCGNodes;
        }

        public int getNumOfCGEdges() {
            return numOfCGEdges;
        }

        public void setNumOfCGEdges(int numOfCGEdges) {
            this.numOfCGEdges = numOfCGEdges;
        }
    }


    // JSON structure
    public static class CGInfo {
        private HashSet<String> sourceNodes;
        private List<Edge> cg;
        private HashSet<String> vulnerableNodes;

        public HashSet<String> getSourceNodes() {
            return sourceNodes;
        }

        public void setSourceNodes(HashSet<String> sourceNodes) {
            this.sourceNodes = sourceNodes;
        }

        public List<Edge> getCg() {
            return cg;
        }

        public void setCg(List<Edge> cg) {
            this.cg = cg;
        }

        public HashSet<String> getVulnerableNodes() {
            return vulnerableNodes;
        }

        public void setVulnerableNodes(HashSet<String> vulnerableNodes) {
            this.vulnerableNodes = vulnerableNodes;
        }

        public Graph convertCGToGraph() {
            var graph = new DefaultDirectedGraph<>(DefaultEdge.class);

            // Add edges to the graph
            for (Edge edge : cg) {
                graph.addVertex(edge.getMethod());
                graph.addVertex(edge.getTarget());
                graph.addEdge(edge.getMethod(), edge.getTarget());
            }
            return graph;
        }
    }

    public static class Edge {
        private String method;
        private String target;

        @JsonCreator
        public Edge(String[] edgeData) {
            if (edgeData != null && edgeData.length == 2) {
                this.method = edgeData[0];
                this.target = edgeData[1];
            }
        }

        public String getMethod() {
            return method;
        }

        public void setMethod(String method) {
            this.method = method;
        }

        public String getTarget() {
            return target;
        }

        public void setTarget(String target) {
            this.target = target;
        }

    }
}
